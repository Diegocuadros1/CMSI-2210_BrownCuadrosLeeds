/ GCD

int gcd(a, b)
{
    if (b == 0)
    {
        return a;
    }
    else
    {
        return gcd(b, a % b);
    }
}

// Stanley Penguin

// a: 24
// b: 18
// amodb: 0
// start: Load     b
//        JZ       done_start:
    ; Prompt and read first number into buffer1
    ; (Code omitted for brevity)

    ; Convert first number to integer
    mov esi, buffer1
    call atoi
    mov [num1], eax         ; Store the first number

    ; Prompt and read second number into buffer2
    ; (Code omitted for brevity)

    ; Convert second number to integer
    mov esi, buffer2
    call atoi
    mov [num2], eax         ; Store the second number

    ; Compute GCD
    mov eax, [num1]
    mov ebx, [num2]
    call gcd                ; Result in eax

    ; Convert GCD result to string
    mov esi, result_buffer + 20 ; Point to the end of the buffer
    call itoa               ; esi will point to the start of the string

    ; Write the result to stdout
    mov edx, result_buffer + 20 - esi ; Calculate string length
    mov ecx, esi            ; Pointer to the result string
    mov eax, 4              ; sys_write
    mov ebx, 1              ; stdout
    int 0x80

    ; Exit
    mov eax, 1              ; sys_exit
    xor ebx, ebx
    int 0x80

section .bss
    num1 resd 1
    num2 resd 1
    result_buffer resb 20

// end:   jmp      end

// problem 1
//  global main
//  extern printf
//  section .text

// mov rdx, 24
// mov rbx, 18
// mov rdx, 0

// cmp rbx, 0x00

// problem 2 fundGCDfunc.nasm | findGCDfunctest.c
// Recreate the above code and create a new file for problem 2
// create file GCDfuncTest.c and run it to test the assembly function

// problem 3
// Count the number of ones in a byte in a number of
// write a nasm program that counts the number of ones in the byte
// if the number is odd, print a 1, else print a 0

//     mov rax, 0x17 ; this is the number to check if even or odd
//     AND rax, 0x01 ; check if the number is odd by ANDing it with 0x01
//     CMP rax, 0x01 ; check if the number is odd by comparing it to 0x01
//     JE count      ; if the number is odd, jump to count

// next: SHR rax, 0x01 ; shift right by 1
//       JMP top       ; jump to top

// count: inc rcx ; increment the count rcx
//        jmp next ; jump to next

// problem 4 do somthing about network byte order

// problem 5
// hton() make network byte order
// ntoh() make network to host byte order

// #include <sys/anet.h>

// problem 6
// makeNBON.nasm

// calls c function

// takes the maximum of three numbers
// global maxofthree
// section .text

// maxofthree:
//     mov rax, rdi
//     cmp rax, rsi
//     cmovl rax, rsi
//     cmp rax, rdx
//     cmovl rax, rdx
//     ret

// gcc -S  //generate assembly from source
